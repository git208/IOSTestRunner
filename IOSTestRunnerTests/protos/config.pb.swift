// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: config.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct StockTesting_MarketPermission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var level: String = String()

  var cffLevel: String = String()

  var dceLevel: String = String()

  var czceLevel: String = String()

  var feLevel: String = String()

  var gilevel: String = String()

  var shfeLevel: String = String()

  var ineLevel: String = String()

  var hkperms: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StockTesting_Site {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ips: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StockTesting_SDKConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appKeyAndroid: String {
    get {return _storage._appKeyAndroid}
    set {_uniqueStorage()._appKeyAndroid = newValue}
  }

  var appKeyIos: String {
    get {return _storage._appKeyIos}
    set {_uniqueStorage()._appKeyIos = newValue}
  }

  var serverSites: Dictionary<String,StockTesting_Site> {
    get {return _storage._serverSites}
    set {_uniqueStorage()._serverSites = newValue}
  }

  var marketPerm: StockTesting_MarketPermission {
    get {return _storage._marketPerm ?? StockTesting_MarketPermission()}
    set {_uniqueStorage()._marketPerm = newValue}
  }
  /// Returns true if `marketPerm` has been explicitly set.
  var hasMarketPerm: Bool {return _storage._marketPerm != nil}
  /// Clears the value of `marketPerm`. Subsequent reads from it will return its default value.
  mutating func clearMarketPerm() {_uniqueStorage()._marketPerm = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct StockTesting_TestcaseConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var testcaseID: String = String()

  var continueWhenFailed: Bool = false

  var roundIntervalSec: Int64 = 0

  var paramStrs: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StockTesting_StoreConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mongoUri: String = String()

  var dbName: String = String()

  var collectionName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StockTesting_RunnerConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var jobID: String {
    get {return _storage._jobID}
    set {_uniqueStorage()._jobID = newValue}
  }

  var runnerID: String {
    get {return _storage._runnerID}
    set {_uniqueStorage()._runnerID = newValue}
  }

  var sdkConfig: StockTesting_SDKConfig {
    get {return _storage._sdkConfig ?? StockTesting_SDKConfig()}
    set {_uniqueStorage()._sdkConfig = newValue}
  }
  /// Returns true if `sdkConfig` has been explicitly set.
  var hasSdkConfig: Bool {return _storage._sdkConfig != nil}
  /// Clears the value of `sdkConfig`. Subsequent reads from it will return its default value.
  mutating func clearSdkConfig() {_uniqueStorage()._sdkConfig = nil}

  var casesConfig: [StockTesting_TestcaseConfig] {
    get {return _storage._casesConfig}
    set {_uniqueStorage()._casesConfig = newValue}
  }

  var storeConfig: StockTesting_StoreConfig {
    get {return _storage._storeConfig ?? StockTesting_StoreConfig()}
    set {_uniqueStorage()._storeConfig = newValue}
  }
  /// Returns true if `storeConfig` has been explicitly set.
  var hasStoreConfig: Bool {return _storage._storeConfig != nil}
  /// Clears the value of `storeConfig`. Subsequent reads from it will return its default value.
  mutating func clearStoreConfig() {_uniqueStorage()._storeConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stock_testing"

extension StockTesting_MarketPermission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MarketPermission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Level"),
    2: .same(proto: "CffLevel"),
    3: .same(proto: "DceLevel"),
    4: .same(proto: "CzceLevel"),
    5: .same(proto: "FeLevel"),
    6: .same(proto: "GILevel"),
    7: .same(proto: "ShfeLevel"),
    8: .same(proto: "IneLevel"),
    9: .same(proto: "HKPerms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.level)
      case 2: try decoder.decodeSingularStringField(value: &self.cffLevel)
      case 3: try decoder.decodeSingularStringField(value: &self.dceLevel)
      case 4: try decoder.decodeSingularStringField(value: &self.czceLevel)
      case 5: try decoder.decodeSingularStringField(value: &self.feLevel)
      case 6: try decoder.decodeSingularStringField(value: &self.gilevel)
      case 7: try decoder.decodeSingularStringField(value: &self.shfeLevel)
      case 8: try decoder.decodeSingularStringField(value: &self.ineLevel)
      case 9: try decoder.decodeRepeatedStringField(value: &self.hkperms)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.level.isEmpty {
      try visitor.visitSingularStringField(value: self.level, fieldNumber: 1)
    }
    if !self.cffLevel.isEmpty {
      try visitor.visitSingularStringField(value: self.cffLevel, fieldNumber: 2)
    }
    if !self.dceLevel.isEmpty {
      try visitor.visitSingularStringField(value: self.dceLevel, fieldNumber: 3)
    }
    if !self.czceLevel.isEmpty {
      try visitor.visitSingularStringField(value: self.czceLevel, fieldNumber: 4)
    }
    if !self.feLevel.isEmpty {
      try visitor.visitSingularStringField(value: self.feLevel, fieldNumber: 5)
    }
    if !self.gilevel.isEmpty {
      try visitor.visitSingularStringField(value: self.gilevel, fieldNumber: 6)
    }
    if !self.shfeLevel.isEmpty {
      try visitor.visitSingularStringField(value: self.shfeLevel, fieldNumber: 7)
    }
    if !self.ineLevel.isEmpty {
      try visitor.visitSingularStringField(value: self.ineLevel, fieldNumber: 8)
    }
    if !self.hkperms.isEmpty {
      try visitor.visitRepeatedStringField(value: self.hkperms, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StockTesting_MarketPermission, rhs: StockTesting_MarketPermission) -> Bool {
    if lhs.level != rhs.level {return false}
    if lhs.cffLevel != rhs.cffLevel {return false}
    if lhs.dceLevel != rhs.dceLevel {return false}
    if lhs.czceLevel != rhs.czceLevel {return false}
    if lhs.feLevel != rhs.feLevel {return false}
    if lhs.gilevel != rhs.gilevel {return false}
    if lhs.shfeLevel != rhs.shfeLevel {return false}
    if lhs.ineLevel != rhs.ineLevel {return false}
    if lhs.hkperms != rhs.hkperms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StockTesting_Site: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Site"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ips"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.ips)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ips.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ips, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StockTesting_Site, rhs: StockTesting_Site) -> Bool {
    if lhs.ips != rhs.ips {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StockTesting_SDKConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SDKConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appKeyAndroid"),
    2: .same(proto: "appKeyIOS"),
    3: .same(proto: "serverSites"),
    4: .same(proto: "marketPerm"),
  ]

  fileprivate class _StorageClass {
    var _appKeyAndroid: String = String()
    var _appKeyIos: String = String()
    var _serverSites: Dictionary<String,StockTesting_Site> = [:]
    var _marketPerm: StockTesting_MarketPermission? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _appKeyAndroid = source._appKeyAndroid
      _appKeyIos = source._appKeyIos
      _serverSites = source._serverSites
      _marketPerm = source._marketPerm
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._appKeyAndroid)
        case 2: try decoder.decodeSingularStringField(value: &_storage._appKeyIos)
        case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StockTesting_Site>.self, value: &_storage._serverSites)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._marketPerm)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._appKeyAndroid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appKeyAndroid, fieldNumber: 1)
      }
      if !_storage._appKeyIos.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appKeyIos, fieldNumber: 2)
      }
      if !_storage._serverSites.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,StockTesting_Site>.self, value: _storage._serverSites, fieldNumber: 3)
      }
      if let v = _storage._marketPerm {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StockTesting_SDKConfig, rhs: StockTesting_SDKConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._appKeyAndroid != rhs_storage._appKeyAndroid {return false}
        if _storage._appKeyIos != rhs_storage._appKeyIos {return false}
        if _storage._serverSites != rhs_storage._serverSites {return false}
        if _storage._marketPerm != rhs_storage._marketPerm {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StockTesting_TestcaseConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestcaseConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "testcaseID"),
    2: .same(proto: "continueWhenFailed"),
    3: .same(proto: "roundIntervalSec"),
    4: .same(proto: "paramStrs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.testcaseID)
      case 2: try decoder.decodeSingularBoolField(value: &self.continueWhenFailed)
      case 3: try decoder.decodeSingularInt64Field(value: &self.roundIntervalSec)
      case 4: try decoder.decodeRepeatedStringField(value: &self.paramStrs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.testcaseID.isEmpty {
      try visitor.visitSingularStringField(value: self.testcaseID, fieldNumber: 1)
    }
    if self.continueWhenFailed != false {
      try visitor.visitSingularBoolField(value: self.continueWhenFailed, fieldNumber: 2)
    }
    if self.roundIntervalSec != 0 {
      try visitor.visitSingularInt64Field(value: self.roundIntervalSec, fieldNumber: 3)
    }
    if !self.paramStrs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.paramStrs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StockTesting_TestcaseConfig, rhs: StockTesting_TestcaseConfig) -> Bool {
    if lhs.testcaseID != rhs.testcaseID {return false}
    if lhs.continueWhenFailed != rhs.continueWhenFailed {return false}
    if lhs.roundIntervalSec != rhs.roundIntervalSec {return false}
    if lhs.paramStrs != rhs.paramStrs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StockTesting_StoreConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoreConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mongoUri"),
    2: .same(proto: "dbName"),
    3: .same(proto: "collectionName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.mongoUri)
      case 2: try decoder.decodeSingularStringField(value: &self.dbName)
      case 3: try decoder.decodeSingularStringField(value: &self.collectionName)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mongoUri.isEmpty {
      try visitor.visitSingularStringField(value: self.mongoUri, fieldNumber: 1)
    }
    if !self.dbName.isEmpty {
      try visitor.visitSingularStringField(value: self.dbName, fieldNumber: 2)
    }
    if !self.collectionName.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StockTesting_StoreConfig, rhs: StockTesting_StoreConfig) -> Bool {
    if lhs.mongoUri != rhs.mongoUri {return false}
    if lhs.dbName != rhs.dbName {return false}
    if lhs.collectionName != rhs.collectionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StockTesting_RunnerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunnerConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jobID"),
    2: .same(proto: "runnerID"),
    3: .same(proto: "sdkConfig"),
    4: .same(proto: "casesConfig"),
    5: .same(proto: "storeConfig"),
  ]

  fileprivate class _StorageClass {
    var _jobID: String = String()
    var _runnerID: String = String()
    var _sdkConfig: StockTesting_SDKConfig? = nil
    var _casesConfig: [StockTesting_TestcaseConfig] = []
    var _storeConfig: StockTesting_StoreConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _jobID = source._jobID
      _runnerID = source._runnerID
      _sdkConfig = source._sdkConfig
      _casesConfig = source._casesConfig
      _storeConfig = source._storeConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._jobID)
        case 2: try decoder.decodeSingularStringField(value: &_storage._runnerID)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._sdkConfig)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._casesConfig)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._storeConfig)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._jobID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._jobID, fieldNumber: 1)
      }
      if !_storage._runnerID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runnerID, fieldNumber: 2)
      }
      if let v = _storage._sdkConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._casesConfig.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._casesConfig, fieldNumber: 4)
      }
      if let v = _storage._storeConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StockTesting_RunnerConfig, rhs: StockTesting_RunnerConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._jobID != rhs_storage._jobID {return false}
        if _storage._runnerID != rhs_storage._runnerID {return false}
        if _storage._sdkConfig != rhs_storage._sdkConfig {return false}
        if _storage._casesConfig != rhs_storage._casesConfig {return false}
        if _storage._storeConfig != rhs_storage._storeConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
